#include <iostream>
using namespace std;
/*
이 문제는 DFS의 한 종류로 브루트 포스 개념이 적용되는 문제입니다.
재귀함수를 통해 상태 공간 트리의 말단노드들의 개수들 중에서 문제에 구하고자 하는 합 S와 비교하여
같을 경우를 세는 문제입니다.
*/
int arr[21];	//집합의 원소를 저장할 배열
int cnt = 0, n, t;	//최종적으로 저장할 부분집합의 경우의 수와 집합의 원소들을 조합하기 위한 최대의 경우의 수를 저장합니다. (집합의 원소의 개수가 곧 조합할 수 있는최대의 경우의 수입니다.)
void dfs(int level, int sum) {
	if (level == n) {
		if (sum == t) {
			cnt++;
		}
		return;
	}
	dfs(level + 1, sum + arr[level]);//상태공간트리에서 경우의 수는 총 두 가지로 나뉩니다. 집합의 level번째, 즉 (집합의 i번째 요소)를 더할 것인지 
	dfs(level + 1, sum);			//더하지 않을 것인지로 모든 경우의 수를 조합하여 상태공간트리에 나타낼 수 있습니다.
}
int main()
{
	cin >> n;
	cin >> t;
	for (int i = 0; i < n; i++) {
		scanf("%d", &arr[i]);
	}

	dfs(0, 0);	//상태공간 트리의 루트노드부터 왼쪽부터 탐색합니다.
	if (t == 0) cnt--; //최종적으로 조합하고자 하는 수가 0일경우엔, 변수t의 값이 0으로 초기화 되어 있으므로 공집합일때 아무것도 더하지 않아 그대로 0이 되어 cnt에 더해지므로 그 경우의 수를 생각하여 -1을 해줍니다.
	cout << cnt << endl;
	return 0;
}